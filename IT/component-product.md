---
layout: page
title: 성분별 곱셈 (Component Product)
description: >
  벡터의 성분별 곱셈과 그 특징에 대해 알아봅니다.
sitemap: false
hide_last_modified: true
categories: [game-dev]
tags: [physics, math]
---

# 성분별 곱셈 (Component Product)

## 개요

성분별 곱셈은 가장 직관적이지만 상대적으로 덜 유용한 벡터 곱셈 방식입니다. 이 책에서는 ◦ 기호로 표현하지만, 다른 벡터 곱셈들과 달리 보편적으로 사용되는 표준 기호는 없습니다.

물리 엔진에서 여러 곳에 사용되지만, 벡터 수학 서적에서는 거의 다루지 않습니다. 이는 기하학적 해석이 단순하지 않기 때문입니다. 두 벡터가 위치를 나타낼 때, 그들의 성분별 곱의 기하학적 의미가 명확하지 않습니다.

## 수학적 정의

성분별 곱셈은 벡터의 덧셈이나 뺄셈과 유사하게, 각 성분을 개별적으로 곱하는 방식으로 이루어집니다:

```
a ◦ b = ⎡ax⎤   ⎡bx⎤   ⎡axbx⎤
        ⎢ay⎥ ◦ ⎢by⎥ = ⎢ayby⎥
        ⎣az⎦   ⎣bz⎦   ⎣azbz⎦
```

주목할 점은 성분별 곱셈의 결과가 또 다른 벡터라는 것입니다. 이는 벡터의 덧셈, 뺄셈, 스칼라 곱셈과 같은 특징입니다: 모두 벡터를 결과로 반환합니다.

## C++ 구현

일반적으로 많이 사용되지 않기 때문에, 성분별 곱셈은 연산자 오버로딩 대신 메서드로 구현합니다. (* 연산자는 다른 종류의 곱셈을 위해 예약해둡니다.)

```cpp
class Vector3 {
public:
    /**
     * 이 벡터와 주어진 벡터의 성분별 곱을 계산하여 반환합니다.
     */
    Vector3 componentProduct(const Vector3 &vector) const {
        return Vector3(x * vector.x, 
                      y * vector.y, 
                      z * vector.z);
    }

    /**
     * 주어진 벡터와의 성분별 곱을 계산하여 
     * 이 벡터를 결과값으로 업데이트합니다.
     */
    void componentProductUpdate(const Vector3 &vector) {
        x *= vector.x;
        y *= vector.y;
        z *= vector.z;
    }
};
```

## 특징

1. **결과 타입**
   - 결과는 새로운 벡터
   - 각 성분이 독립적으로 계산됨

2. **기하학적 해석**
   - 명확한 기하학적 의미가 없음
   - 위치 벡터에 대해 직관적이지 않은 결과

3. **사용 사례**
   - 특정 축의 스케일링
   - 마스킹 연산
   - 개별 축 기반 연산

## 주의사항

1. **연산자 선택**
   - 표준 기호가 없음
   - 메서드 형태로 구현 권장

2. **성능**
   - 단순한 연산으로 구성
   - 병렬 처리에 적합

3. **활용**
   - 목적에 맞는 경우에만 사용
   - 다른 벡터 곱셈이 더 적합한지 검토 