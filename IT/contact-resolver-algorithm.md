---
layout: page
title: 충돌 해결 알고리즘 (Contact Resolver Algorithm)
description: >
  물리 엔진에서 충돌 해결 알고리즘과 제약 조건의 구현
hide_description: false
lang: ko
---

## 충돌 해결 알고리즘의 개요

충돌 해결기는 충돌 감지 시스템으로부터 접촉 목록을 받아 시뮬레이션 중인 객체를 업데이트하여 접촉을 처리합니다. 이를 위한 세 가지 핵심 코드가 있습니다:

1. **충돌 해결 함수**: 객체에 충격량을 적용하여 튕겨져 나가는 것을 시뮬레이션합니다.
2. **침투 해결 함수**: 객체가 서로 부분적으로 겹치지 않도록 분리합니다.
3. **정지 접촉 코드**: 충돌 해결 함수 내에서 충돌이 아닌 정지 접촉일 수 있는 접촉을 감시합니다.

어떤 함수를 호출할지는 접촉의 분리 속도와 침투 깊이에 따라 달라집니다. 침투 깊이가 0보다 큰 경우에만 침투 해결이 필요합니다. 마찬가지로 객체가 침투되어 있지만 분리되고 있는 경우 충돌 해결 없이 침투 해결만 수행할 수 있습니다.

## 해결 순서

한 객체가 두 개의 동시 접촉을 가지고 있을 때, 한 접촉을 해결하기 위해 속도를 변경하면 다른 접촉의 분리 속도가 변경될 수 있습니다. 예를 들어, 첫 번째 접촉을 해결하면 두 번째 접촉은 더 이상 충돌이 아닐 수 있습니다. 반면, 두 번째 접촉만 해결하면 첫 번째 접촉은 여전히 해결이 필요할 수 있습니다.

이런 상황에서 불필요한 작업을 피하기 위해 가장 심각한 접촉(분리 속도가 가장 낮은, 즉 가장 부정적인 접촉)을 먼저 해결합니다. 이는 편리할 뿐만 아니라 물리적으로 가장 현실적인 접근 방식입니다. 가장 심각한 충돌이 시뮬레이션의 동작을 지배하는 경향이 있기 때문입니다.

하지만 한 가지 문제가 있습니다. 한 충돌을 처리하면 다른 접촉의 분리 속도가 변경될 수 있습니다. 따라서 접촉을 분리 속도별로 정렬한 다음 순서대로 처리할 수 없습니다. 첫 번째 충돌을 처리한 후에는 다음 접촉의 분리 속도가 양수가 되어 처리가 필요하지 않을 수 있습니다.

또한, 더 미묘한 문제도 있습니다. 하나의 접촉을 해결한 다음 다른 접촉을 해결하지만, 두 번째 접촉의 해결이 첫 번째 접촉을 다시 충돌 상태로 되돌리는 상황이 발생할 수 있습니다. 다행히도 특정 유형의 시뮬레이션(특히 마찰이 없는 경우)에서는 이 루프가 결국 올바른 답으로 수렴할 것으로 증명되었습니다. 하지만 도달하는 데 오랜 시간이 걸릴 수 있으므로, 각 프레임에서 수행할 수 있는 해결 횟수에 제한을 둡니다.

## 충돌 해결기 알고리즘

충돌 해결기가 사용하는 알고리즘은 다음과 같습니다:

1. 각 접촉의 분리 속도를 계산하고, 가장 낮은(즉, 가장 부정적인) 값을 가진 접촉을 추적합니다.
2. 가장 낮은 분리 속도가 0 이상이면 완료된 것입니다: 알고리즘을 종료합니다.
3. 가장 낮은 분리 속도를 가진 접촉에 대해 충돌 응답 알고리즘을 처리합니다.
4. 더 많은 반복이 있으면 1단계로 돌아갑니다.

이 알고리즘은 이전에 해결한 접촉을 자동으로 재검토하고 분리 중인 접촉은 무시합니다. 각 반복에서 가장 심각한 충돌을 해결합니다.

반복 횟수는 최소한 접촉 수(모든 접촉이 적어도 한 번 처리될 기회를 주기 위해)와 같거나 더 많아야 합니다. 간단한 입자 시뮬레이션의 경우 접촉 수와 동일한 반복 횟수로도 충분한 경우가 많습니다. 경험적으로 접촉 수의 두 배를 사용하는 경향이 있지만, 복잡하고 상호 연결된 접촉 세트에는 더 많은 반복이 필요합니다.

## 침투 해결

침투를 해결하는 더 좋은 해결책은 충돌 해결과 침투 해결을 별도의 단계로 분리하는 것입니다. 먼저 이전 알고리즘을 사용하여 순서대로 충돌을 해결합니다. 그런 다음 침투를 해결합니다.

두 해결 단계를 분리하면 속도와 다른 침투 해결 순서를 사용할 수 있습니다. 다시 한 번 가장 현실적인 결과를 얻기 위해 이전과 마찬가지로 심각도 순서대로 접촉을 해결합니다. 두 단계를 결합하면 한 종류의 해결에 대해 최적이 아닌 순서에 묶이게 됩니다.

침투 해결은 충돌 해결과 동일한 알고리즘을 따릅니다. 이전과 마찬가지로 각 반복 사이에 모든 침투 깊이를 다시 계산해야 합니다. 침투 깊이는 충돌 감지기에서 제공한다는 점을 기억하세요. 각 반복 후에 충돌 감지를 다시 수행하는 것은 너무 시간이 많이 소요됩니다. 침투 깊이를 업데이트하기 위해 이전 반복에서 두 객체를 얼마나 이동했는지 추적합니다. 각 접촉의 객체를 검사하여 마지막 프레임에서 이동된 객체가 있으면 접촉 법선 방향으로 이동한 구성 요소를 찾아 침투 깊이를 업데이트합니다.

## 시간 분할 엔진(Time-Division Engines)

물리 엔진을 만드는 또 다른 접근 방식은 침투를 해결하거나 접촉에 대한 합리적인 해결 순서를 생성할 필요를 피하는 것입니다. 프레임당 물리 엔진의 단일 업데이트 대신, 충돌로 구분된 여러 업데이트를 가질 수 있습니다.

이론은 다음과 같습니다:

- 충돌이 없을 때 객체는 마지막 장에서 본 운동 및 힘 생성기의 법칙만 사용하여 자유롭게 움직입니다.
- 충돌이 발생할 때는 두 객체가 닿는 정확한 지점입니다. 이 단계에서는 침투가 없습니다.
- 충돌이 발생하는 정확한 시간을 감지할 수 있다면, 이 지점까지는 일반적인 운동 법칙을 사용하고, 정지한 다음, 충격량 계산을 수행한 후, 다시 일반적인 운동 법칙으로 시작할 수 있습니다.
- 여러 충돌이 있는 경우, 순서대로 처리합니다. 각 충돌 사이에서 일반적인 운동 법칙을 사용하여 세계를 업데이트합니다.

이러한 방식의 엔진은 다음과 같은 알고리즘을 가집니다:

1. 시작 시간을 현재 시뮬레이션 시간으로, 종료 시간을 현재 업데이트 요청의 끝으로 설정합니다.
2. 전체 시간 간격에 대해 완전한 업데이트를 수행합니다.
3. 충돌 감지기를 실행하고 충돌 목록을 수집합니다.
4. 충돌이 없으면 완료되었습니다: 알고리즘을 종료합니다.
5. 각 충돌에 대해 첫 번째 충돌의 정확한 시간을 계산합니다.
6. 가장 먼저 발생한 충돌을 선택합니다.
7. 첫 번째 충돌이 종료 시간 이후에 발생하면 완료되었습니다: 알고리즘을 종료합니다.
8. 2단계의 완전한 업데이트를 제거하고, 시작 시간부터 첫 번째 충돌 시간까지 업데이트를 수행합니다.
9. 충돌을 처리하고 적절한 충격량을 적용합니다(충돌 순간에 객체가 막 닿고 있기 때문에 침투 해결이 필요하지 않습니다).
10. 시작 시간을 첫 번째 충돌 시간으로 설정하고, 종료 시간은 변경하지 않은 상태로 1단계로 돌아갑니다.

이는 정확한 결과를 제공하고 침투 해결 문제를 피합니다. 정확성이 중요한 엔지니어링 물리 애플리케이션에서 일반적으로 사용되는 알고리즘입니다. 그러나 이는 매우 시간이 많이 소요됩니다.

각 충돌에 대해 충돌 감지기를 다시 실행하고 일반 물리 업데이트를 다시 실행합니다. 정지 접촉을 처리하기 위한 특수 코드도 필요합니다. 그렇지 않으면 정지 접촉은 모든 반복에서 첫 번째 충돌로 반환됩니다.

대부분의 게임 프로젝트에서 이 접근 방식은 실용적이지 않습니다. 프레임당 한 번 업데이트로 모든 접촉의 속도와 침투를 해결하는 것이 더 나은 해결책입니다.

예외적인 경우는 당구, 스누커 또는 비리야드 게임입니다. 이러한 게임에서는 충돌 순서와 충돌 시 공의 위치가 중요합니다. 프레임당 한 번 물리학을 사용하는 당구 게임은 두 공이 충돌할 때 믿을 수 있지만, 큐 공이 서로 촘촘하게 모여 있는(그러나 접촉하지 않는) 공들에 부딪힐 때 이상한 효과가 나타날 수 있습니다.

## 충돌과 유사한 제약 조건

### 케이블(Cables)

케이블은 두 객체가 그 길이 이상 떨어지지 않도록 강제하는 제약 조건입니다. 가벼운 케이블로 연결된 두 객체는 가까이 있는 한 영향을 느끼지 않습니다. 케이블이 팽팽하게 당겨지면 객체는 더 이상 분리될 수 없습니다.

케이블의 특성에 따라 객체는 이 한계에서 튕겨나갈 수 있습니다. 케이블은 이 튕김 효과를 제어하는 특성 반발 계수를 가지고 있습니다.

케이블의 끝이 너무 멀리 분리될 때마다 접촉을 생성하여 케이블을 모델링할 수 있습니다. 접촉은 충돌에 사용되는 것과 매우 유사하지만 접촉 법선이 반대입니다: 객체를 튕겨내지 않고 함께 당깁니다. 접촉의 침투 깊이는 케이블이 한계를 넘어 얼마나 늘어났는지에 해당합니다.

### 막대(Rods)

막대는 케이블과 충돌의 동작을 결합합니다. 막대로 연결된 두 객체는 분리되거나 가까워질 수 없습니다. 그들은 고정된 거리를 유지합니다.

케이블 접촉 생성기와 동일한 방식으로 이를 구현할 수 있습니다. 매 프레임마다 막대의 현재 상태를 확인하고 끝을 안쪽으로 가져오는 접촉이나 분리하는 접촉을 생성합니다.

그러나 두 가지 수정이 필요합니다. 첫째, 항상 0의 반발 계수를 사용해야 합니다. 두 끝이 함께 또는 떨어져서 튕기는 것은 의미가 없습니다. 둘째, 각 프레임에서 두 접촉(분리하거나 닫기 위한) 중 하나만 적용하면 진동하는 막대가 생깁니다. 이를 피하기 위해 매 프레임마다 두 접촉을 모두 생성합니다.

## 요약

우리는 이제 하드 제약 조건(막대와 케이블 등)과 탄성 제약 조건(스프링과 번지 등)을 모두 사용하여 입자를 연결할 수 있는 물리 코드 세트를 구축했습니다.

막대와 케이블은 별도의 객체 간의 충돌과 유사하게 작동합니다. 케이블은 충돌 시 서로 튕겨나가는 것과 마찬가지로 연결된 입자가 서로 튕겨나가게 할 수 있습니다. 마찬가지로 막대는 연결된 입자가 함께 있도록 하여 고정된 분리 거리로 움직이게 합니다. 이는 튕김이 없는 충돌에 해당합니다. 입자가 서로 붙고 접근 속도가 0으로 감소합니다.

입자 간의 하드 및 탄성 연결을 모두 지원하면 흥미로운 구조를 구축하고 게임에서 시뮬레이션할 수 있습니다.

이것은 우리의 두 번째 완전한 물리 엔진인 질량 집합체 엔진(mass-aggregate engine)을 형성합니다. 먼저 구축한 입자 엔진과 달리 질량 집합체 엔진은 출시된 게임에서는 드문 편입니다. 많은 2차원 플랫폼 게임에서 효과적으로 사용되었지만, 이 책의 뒷부분에서 설명하는 더 복잡한 엔진에 의해 대체되었습니다. 그럼에도 불구하고 일부 게임에서는 여전히 유용합니다. 