---
layout: page
title: 하드 컨스트레인트 (Hard Constraints)
description: >
  게임 물리 엔진에서의 하드 컨스트레인트 개념과 충돌 해결 방법
hide_description: false
lang: ko
---

## 하드 컨스트레인트 개요

스프링과 같은 힘 생성기는 많은 상황을 표현할 수 있지만, 때로는 문제가 발생할 수 있습니다. 객체들이 단단하게 연결되어야 하는 경우, 필요한 스프링 상수는 실질적으로 시뮬레이션하기 거의 불가능합니다. 단단한 막대로 연결된 객체나 딱딱한 표면으로 분리된 객체 등의 상황에서는 스프링이 적합하지 않습니다.

하드 컨스트레인트는 이런 상황을 해결하기 위한 방법입니다. 가장 일반적인 하드 컨스트레인트는 객체 간의 충돌과 접촉입니다. 동일한 수학적 방법은 객체를 연결하는 데 사용할 수 있는 막대나 늘어나지 않는 케이블과 같은 다른 종류의 하드 컨스트레인트에도 사용될 수 있습니다.

## 1. 간단한 충돌 해결

하드 컨스트레인트를 처리하기 위해 충돌 해결 시스템을 추가합니다. 여기서 "충돌"은 두 객체가 접촉하는 모든 상황을 의미합니다. 일상 언어에서는 충돌이 상당한 접근 속도로 두 객체가 만나는 폭력적인 과정이라고 생각하지만, 이 맥락에서는 접근 속도가 없이 그저 접촉하고 있는 두 객체도 충돌 상태에 있다고 간주합니다.

### 접근 속도(Closing Velocity)

충돌하는 물체의 움직임을 지배하는 법칙은 그들의 접근 속도에 따라 달라집니다. 접근 속도는 두 객체가 함께 움직이는 총 속도입니다. 방향에 따라 부호가 있는 속도이며, 서로 멀어지는 두 객체는 0보다 작은 접근 속도를 갖게 됩니다.

두 객체의 접근 속도는 한 객체에서 다른 객체로의 방향으로 속도 성분을 계산하여 구합니다:

<div style="font-size: 1.5em; text-align: center; margin: 20px 0;">
vc = -((p˙<sub>a</sub> - p˙<sub>b</sub>) · (p<sub>a</sub> - p<sub>b</sub>))
</div>

여기서 vc는 접근 속도(스칼라 값), pa와 pb는 객체 a와 b의 위치, 점(·)은 스칼라 곱입니다.

관습적으로 이 값의 부호를 바꾸어 분리 속도(separating velocity)를 사용하는 것이 더 일반적입니다:

<div style="font-size: 1.5em; text-align: center; margin: 20px 0;">
vs = (p˙<sub>a</sub> - p˙<sub>b</sub>) · (p<sub>a</sub> - p<sub>b</sub>)
</div>

이 경우 서로 접근하는 두 객체는 음의 상대 속도를 가지며, 분리되는 객체는 양의 속도를 갖습니다.

### 반발 계수(Coefficient of Restitution)

두 객체가 충돌할 때, 그들은 함께 압축되고, 표면의 스프링 같은 변형이 객체를 분리시키는 힘을 발생시킵니다. 이 모든 과정은 매우 짧은 시간에 일어납니다. 결국 두 객체는 더 이상 접근 속도를 갖지 않게 됩니다.

대부분의 충돌은 거의 스프링과 같은 이상적인 모델처럼 작동합니다. 운동량 보존을 가정하면 완벽하게 믿을 수 있는 동작을 생성할 수 있습니다:

<div style="font-size: 1.5em; text-align: center; margin: 20px 0;">
m<sub>a</sub>p˙<sub>a</sub> + m<sub>b</sub>p˙<sub>b</sub> = m<sub>a</sub>p˙<sub>a</sub>' + m<sub>b</sub>p˙<sub>b</sub>'
</div>

여기서 ma는 객체 a의 질량이고, p˙a는 충돌 전 객체 a의 속도이며, p˙a'는 충돌 후 속도입니다.

각 객체의 개별 속도는 분리 속도를 사용하여 연결됩니다:

<div style="font-size: 1.5em; text-align: center; margin: 20px 0;">
v<sub>s</sub>' = -cv<sub>s</sub>
</div>

여기서 vs'는 충돌 후 분리 속도, vs는 충돌 전 분리 속도, c는 "반발 계수"라고 불리는 상수입니다.

반발 계수는 객체가 충돌 후 분리되는 속도를 제어합니다. 재질에 따라 다른 계수를 가집니다. 당구공이나 테니스 라켓의 테니스 공과 같은 물체는 튕겨져 나가고, 눈덩이와 누군가의 얼굴처럼 충돌 시 달라붙는 물체도 있습니다.

계수가 1이면 객체는 접근할 때와 같은 속도로 튕겨져 나갑니다. 계수가 0이면 객체는 융합되어 함께 이동합니다(즉, 분리 속도는 0이 됩니다).

### 충돌 방향과 접촉 법선(Contact Normal)

객체와 물리적으로 시뮬레이션하지 않는 것(예: 지면, 레벨의 벽 등) 사이의 충돌도 지원하고 싶을 때가 있습니다. 이런 경우 객체 하나와 움직이지 않는 시나리오 사이의 충돌이 있으면, 각 객체 위치 사이의 벡터를 사용하여 분리 속도를 계산할 수 없습니다.

(pa - pb) 항은 분리 속도가 발생하는 방향을 제공합니다. 두 객체가 없는 경우 방향을 명시적으로 제공받을 수 있습니다. 이것이 두 객체가 충돌하는 방향이며 일반적으로 "충돌 법선" 또는 "접촉 법선"이라고 합니다. 방향이기 때문에 벡터의 크기는 항상 1이어야 합니다.

두 입자가 충돌하는 경우, 접촉 법선은 항상 다음과 같이 주어집니다:

<div style="font-size: 1.5em; text-align: center; margin: 20px 0;">
n̂ = (p<sub>a</sub> - p<sub>b</sub>)
</div>

입자가 지면과 충돌할 때, 우리는 객체 a(입자)만 있고 객체 b는 없습니다. 이 경우 객체 a의 관점에서 접촉 법선은 다음과 같습니다(지면이 충돌 지점에서 수평이라고 가정):

<div style="font-size: 1.5em; text-align: center; margin: 20px 0;">
n̂ = [0, 1, 0]
</div>

올바른 접촉 법선을 사용하면, 분리 속도 방정식은 다음과 같이 변경됩니다:

<div style="font-size: 1.5em; text-align: center; margin: 20px 0;">
vs = (p˙<sub>a</sub> - p˙<sub>b</sub>) · n̂
</div>

### 충격량(Impulses)

충돌을 해결하기 위해 변경해야 하는 것은 속도뿐입니다. 지금까지 물리 엔진에서는 가속도를 사용해 속도를 변경했습니다. 여기서 변화는 즉각적입니다: 속도는 즉시 새로운 값을 갖습니다.

힘을 적용하면 객체의 가속도가 변한다는 것을 기억하세요. 힘을 즉시 변경하면 가속도도 즉시 변합니다. 객체에 작용하여 속도를 변경하는 것도 비슷하게 생각할 수 있습니다. 이를 "충격량(impulse)"이라고 합니다: 속도의 즉각적인 변화입니다. 힘에 대해 다음과 같은 관계가 있듯이:

<div style="font-size: 1.5em; text-align: center; margin: 20px 0;">
f = mp̈
</div>

충격량 g에 대해서는 다음과 같은 관계가 있습니다:

<div style="font-size: 1.5em; text-align: center; margin: 20px 0;">
g = mp˙
</div>

하지만 힘과 충격량 사이에는 중요한 차이가 있습니다. 객체는 힘을 받지 않는 한 가속도를 가지지 않습니다. 반면에 객체는 충격량(또는 힘)이 작용하지 않더라도 속도를 계속 유지합니다. 따라서 충격량은 속도를 변경하지만, 속도에 대해 완전히 책임이 있는 것은 아닙니다.

충격량을 달랑베르의 원리를 사용하여 결합할 수 있지만, 그 결과는 총 속도가 아니라 속도의 총 변화가 됩니다:

<div style="font-size: 1.5em; text-align: center; margin: 20px 0;">
p˙' = p˙ + (1/m) Σ g<sub>i</sub>
</div>

여기서 g1 ... gn은 객체에 작용하는 모든 충격량의 집합입니다.

실제로는 힘을 누적했던 방식으로 충격량을 누적하지 않을 것입니다. 충돌 해결 과정에서 발생할 때 충격량을 적용할 것입니다. 각각은 다음 방정식을 사용하여 한 번에 하나씩 적용됩니다:

<div style="font-size: 1.5em; text-align: center; margin: 20px 0;">
p˙' = p˙ + (1/m)g
</div>

충돌 해결의 결과는 각 객체에 적용할 충격량이 될 것입니다. 충격량은 즉시 적용되어 객체의 속도를 즉시 변경합니다.

## 2. 충돌 처리

충돌을 처리하기 위해 우리는 ContactResolver라는 새로운 코드를 만들 것입니다. 이것은 전체 충돌 세트를 가져와 관련 객체에 적절한 충격량을 적용하는 역할을 합니다. 각 충돌은 Contact 데이터 구조로 제공됩니다.

```cpp
class ParticleContact
{
public:
    // 충돌에 관련된 입자들을 저장합니다.
    // 두 번째 입자는 지형과의 충돌인 경우 NULL일 수 있습니다.
    Particle* particle[2];
    
    // 충돌 지점에서의 반발 계수를 저장합니다.
    real restitution;
    
    // 세계 좌표에서의 충돌 방향을 저장합니다.
    Vector3 contactNormal;
};
```

이 구조체는 충돌에 관련된 각 객체에 대한 포인터, 첫 번째 객체의 관점에서 접촉 법선을 나타내는 벡터, 그리고 접촉의 반발 계수를 위한 데이터 멤버를 포함합니다. 객체와 지형(즉, 하나의 객체만 관련된 경우) 사이의 충돌을 다룰 때, 두 번째 객체에 대한 포인터는 NULL이 됩니다.

하나의 접촉을 해결하기 위해 앞서 설명한 충돌 방정식을 구현합니다:

```cpp
class ParticleContact
{
    // ... 이전 ParticleContact 코드 ...
protected:
    // 속도와 침투 모두에 대해 이 접촉을 해결합니다.
    void resolve(real duration);
    
    // 이 접촉에서의 분리 속도를 계산합니다.
    real calculateSeparatingVelocity() const;
    
private:
    // 이 충돌에 대한 충격량 계산을 처리합니다.
    void resolveVelocity(real duration);
};
```

### 충돌 감지(Collision Detection)

충돌 지점은 일반적으로 충돌 감지기를 사용하여 찾습니다. 충돌 감지기는 충돌 중인 객체 쌍이나 움직일 수 없는 지형과 충돌 중인 단일 객체를 찾는 데 책임이 있는 코드 부분입니다.

우리 엔진에서 충돌 감지 알고리즘의 최종 결과는 적절한 정보로 채워진 Contact 데이터 구조 세트입니다. 충돌 감지는 분명히 객체의 기하학적 형태와 크기를 고려해야 합니다. 지금까지 물리 엔진에서는 기하학을 전혀 고려할 필요가 없는 입자를 다루고 있다고 가정했습니다.

물리 시뮬레이션 시스템(운동 법칙, 충돌 해결, 힘을 처리하는 엔진 부분)은 다루는 객체의 형태 세부 사항을 알 필요가 없습니다. 충돌 감지 시스템은 두 객체가 접촉하는 시기와 위치, 그리고 그들 사이의 접촉 법선과 같은 기하학적인 속성을 계산할 책임이 있습니다.

### 침투 해결(Resolving Interpenetration)

두 객체가 서로 침투하고 있을 때, 우리는 그들을 충분히 분리시켜 떨어뜨려 놓습니다. 충돌 감지기가 객체의 침투 깊이를 Contact 데이터 구조의 일부로 알려주기를 기대합니다. 침투 깊이 계산은 충돌하는 객체의 기하학적 형태에 따라 달라지며, 이는 물리 시뮬레이터가 아닌 충돌 감지 시스템의 영역입니다.

침투를 해결하기 위해 Contact 데이터 구조에 이 정보를 저장할 데이터 멤버를 추가합니다:

```cpp
class ParticleContact
{
    // ... 이전 ParticleContact 코드 ...
    
    // 접촉 지점에서의 침투 깊이를 저장합니다.
    real penetration;
};
```

침투를 해결하기 위해 침투 깊이를 확인합니다. 이미 제로 이하라면, 아무 조치도 취할 필요가 없습니다. 그렇지 않다면, 두 객체를 침투 깊이가 0이 될 정도로 충분히 떨어뜨려 놓을 수 있습니다. 침투 깊이는 접촉 법선의 방향으로 주어져야 합니다. 접촉 법선 방향으로 침투 깊이와 같은 거리만큼 객체를 이동시키면, 더 이상 접촉하지 않게 됩니다.

두 객체를 질량에 반비례하게 이동시킵니다. 큰 질량을 가진 객체는 거의 이동하지 않고, 작은 질량을 가진 객체는 많이 이동합니다. 무한 질량을 가진 객체는 전혀 이동하지 않습니다.

각 객체의 총 이동은 침투 깊이와 같습니다:

<div style="font-size: 1.5em; text-align: center; margin: 20px 0;">
p<sub>a</sub> + p<sub>b</sub> = d
</div>

여기서 pa는 객체 a가 이동할 스칼라 거리입니다.

두 거리는 질량의 비율에 따라 서로 관련이 있습니다:

<div style="font-size: 1.5em; text-align: center; margin: 20px 0;">
m<sub>a</sub>p<sub>a</sub> = m<sub>b</sub>p<sub>b</sub>
</div>

이를 결합하면:

<div style="font-size: 1.5em; text-align: center; margin: 20px 0;">
p<sub>a</sub> = (m<sub>b</sub> / (m<sub>a</sub> + m<sub>b</sub>)) · d
</div>

그리고:

<div style="font-size: 1.5em; text-align: center; margin: 20px 0;">
p<sub>b</sub> = (m<sub>a</sub> / (m<sub>a</sub> + m<sub>b</sub>)) · d
</div>

접촉 법선 방향과 결합하면 벡터 위치의 총 변화는 다음과 같습니다:

<div style="font-size: 1.5em; text-align: center; margin: 20px 0;">
p<sub>a</sub> = (m<sub>b</sub> / (m<sub>a</sub> + m<sub>b</sub>)) · d · n
</div>

그리고:

<div style="font-size: 1.5em; text-align: center; margin: 20px 0;">
p<sub>b</sub> = -(m<sub>a</sub> / (m<sub>a</sub> + m<sub>b</sub>)) · d · n
</div>

여기서 n은 접촉 법선입니다. (두 번째 방정식의 마이너스 기호에 주목하세요: 이는 접촉 법선이 객체 a의 관점에서 주어지기 때문입니다.)

## 3. 정지 접촉(Resting Contacts)

정지 접촉은 두 객체가 접촉하고 있지만 접근 속도가 매우 작거나 0인 상황입니다. 이러한 상황에서는 충돌 해결 시스템이 올바르게 작동하지 않을 수 있습니다.

지면에 정지해 있는 입자를 생각해 보세요. 첫 번째 프레임에서 입자는 중력에 의해 아래로 가속합니다. 속도는 증가하지만 위치는 변하지 않습니다(프레임 시작 시 속도가 없음). 두 번째 프레임에서 위치가 업데이트되고 속도가 다시 증가합니다. 이제 입자는 아래로 이동하며 지면과 침투하기 시작합니다. 충돌 감지기가 침투를 감지하고 충돌을 생성합니다.

연락 해석기는 입자를 보고 침투 속도가 있음을 확인하고, 충돌 응답을 적용하여 위쪽 방향으로 속도를 부여합니다. 그 결과 3프레임에서는 입자가 지면에서 떨어져 공중으로 올라갑니다. 이 상향 속도는 작지만 눈에 띌 정도가 될 수 있습니다.

이 문제를 해결하기 위해 두 가지를 할 수 있습니다:

1. 충돌을 더 일찍 감지합니다.
2. 한 프레임 동안만 힘이 작용하여 발생할 수 있는 속도를 갖는 객체를 인식합니다.

객체가 이전 프레임에서 정지해 있었는지 확인하기 위해, 실제 속도가 프레임 지속 시간 동안 힘이 작용하여 발생할 수 있는 속도보다 작거나 같은지(또는 약간 높은지) 확인할 수 있습니다. 이 경우 접촉은 충돌 접촉보다는 정지 접촉일 가능성이 높습니다. 충돌에 대한 충격량 계산을 수행하는 대신, 0 분리 속도를 가져올 충격량을 적용할 수 있습니다.

정지 접촉의 경우, 접근 속도가 쌓일 시간이 없으므로 접촉 후 분리 속도도 없습니다. 이러한 일련의 마이크로 충돌이 객체를 분리된 상태로 유지합니다. 이러한 방식으로 정지 접촉을 처리하는 엔진을 때때로 "마이크로 충돌 엔진"이라고 합니다.

### 속도와 접촉 법선

두 객체가 정지 접촉 상태에 있을 때, 어느 한 쪽의 절대 속도보다는 상대 속도에 관심이 있습니다. 두 객체는 한 방향으로는 정지 접촉 상태에 있지만, 다른 방향으로는 서로를 가로질러 움직일 수 있습니다. 상자는 표면을 미끄러지더라도 지면에 정지하고 있을 수 있습니다.

이러한 상황에 대처하기 위해 속도 및 가속도 계산은 모두 접촉 법선 방향으로만 수행됩니다. 먼저 이 방향의 속도를 찾고 같은 방향의 가속도 구성 요소에 의해서만 발생했는지 테스트합니다. 그렇다면 이 방향으로 분리 또는 접근 속도가 없도록 속도가 변경됩니다. 다른 방향으로 상대 속도가 여전히 있을 수 있지만, 이는 무시됩니다.

### 다른 정지 접촉 접근 방식

마이크로 충돌 접근 방식은 많은 가능성 중 하나에 불과합니다. 정지 접촉은 물리 엔진에서 올바르게 구현하기 위한 두 가지 핵심 과제 중 하나입니다(다른 하나는 마찰입니다: 실제로 두 가지는 종종 함께 발생합니다).

더 물리적으로 현실적인 접근 방식은 현실에서는 지면에서 입자에 힘이 가해질 것임을 인식하는 것입니다. 이 반작용력은 수직 방향의 총 가속도가 0이 되도록 객체를 뒤로 밀어냅니다. 입자가 아무리 강하게 아래로 밀어도, 지면은 같은 힘으로 위로 밀어올립니다. 이러한 방식으로 작동하는 힘 생성기를 만들어 지면으로의 가속을 방지할 수 있습니다.

이것은 지면과 하나의 접촉만 가질 수 있는 입자에 대해서는 잘 작동합니다. 더 복잡한 강체의 경우 상황은 상당히 복잡해집니다. 객체와 지면 사이에 여러 접촉 지점이 있을 수 있습니다. 각 접촉에서의 반작용력을 계산하여 객체의 전체 움직임이 올바르게 되도록 하는 방법은 즉시 명확하지 않습니다. 