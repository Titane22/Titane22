---
layout: page
title: 강성 스프링 문제와 해결책
description: >
  게임 물리 엔진에서 강성 스프링의 문제점과 이를 해결하기 위한 방법
hide_description: false
lang: ko
---

## 개요
현실에서는 거의 모든 것이 스프링처럼 작용합니다. 바위가 지면에 떨어지면 지면은 매우 강한 스프링처럼 약간 휘어집니다. 스프링 동작 모델을 사용하면 거의 모든 것을 시뮬레이션할 수 있습니다. 물체 간의 충돌도 부력과 유사한 방식으로 모델링할 수 있습니다: 물체가 서로 통과하도록 허용하고(이를 "상호 침투"라고 함), 스프링 힘이 그것들을 다시 밀어내는 방식입니다.

각 물체에 대해 올바른 스프링 매개변수를 사용하면 이 방법은 완벽한 충돌을 제공할 수 있습니다. 이를 "페널티 방법"이라고 하며 게임에서 사용되는 여러 물리 시뮬레이터에서 사용되었습니다.

그러나 이 방법에는 중요한 문제가 있습니다: 강성 스프링(stiff springs)의 문제입니다.

## 강성 스프링의 문제

게임에서 모든 것이 스프링처럼 튀어오르는 것을 방지하기 위해 스프링 상수를 매우 높게 설정해야 합니다. 그러나 이렇게 하면 물리 엔진이 불안정해집니다: 물체가 거의 즉시 무한대로 사라지고, 수치 오류로 프로그램이 충돌할 수도 있습니다.

이 문제를 이해하기 위해 스프링의 동작을 짧은 시간 단계로 나누어 살펴봐야 합니다.

### 비강성 스프링의 시간에 따른 동작

<div style="font-size: 1.2em; text-align: center; margin: 20px 0;">
1. 첫 단계에서 스프링이 늘어나고, 그 시점에서 힘을 계산합니다.
2. 이 힘은 3장의 업데이트 함수를 사용하여 스프링 끝에 적용됩니다: p˙ = p˙ + p¨t
3. 즉, 힘은 가속도로 변환되어 전체 시간 간격 동안 물체에 적용됩니다.
</div>

이는 물체가 움직이지 않는다면 정확할 것입니다. 즉, 스프링이 전체 시간 동안 일정한 확장 상태를 유지한다면 정확합니다.

실제 세계에서는 스프링이 조금 움직이자마자 힘이 약간 감소합니다. 따라서 전체 시간 간격 동안 동일한 힘을 적용하면 너무 많은 힘이 적용됩니다. 그러나 비강성 스프링에서는 이것이 큰 문제가 되지 않습니다. 힘이 너무 크더라도 다음 시간 프레임까지 끝이 멀리 이동하지 않고, 다음 시간 프레임에서는 더 낮은 힘이 적용됩니다. 전체적인 효과는 스프링이 정상적으로 작동하지만, 우리가 지정한 스프링 상수보다 약간 더 강성이 있다는 것입니다.

### 강성 스프링의 시간에 따른 동작

<div style="font-size: 1.2em; text-align: center; margin: 20px 0;">
1. 첫 프레임의 힘이 스프링 끝을 휴지 길이를 지나 압축시킬 만큼 충분히 큽니다.
2. 실제로는 스프링 움직임이 이렇게 되지 않을 것입니다: 순간적으로 엄청난 힘이 가해져 안쪽으로 움직이기 시작하지만, 끝이 안쪽으로 움직임에 따라 이 힘은 급격히 감소할 것입니다.
3. 스프링은 원래 확장된 것보다 더 많이 압축됩니다.
4. 다음 시간 프레임에서는 반대 방향으로 움직이지만 더 큰 힘이 적용되어 더 멀리 확장됩니다.
5. 각 시간 프레임에서 스프링은 계속 커지는 힘으로 진동하여 결국 스프링 끝이 무한대에 도달합니다.
</div>

이는 명백히 정확하지 않습니다. 우리가 사용하는 시간 프레임이 길수록 이런 일이 발생할 가능성이 높아집니다. 게임에서 스프링을 사용하고 가변 프레임 속도를 사용한다면, 매우 느린 기계에서 사용될 때 스프링 상수가 너무 크지 않도록 주의해야 합니다.

## 강성 스프링 문제의 해결책

### 1. 작은 시간 간격 강제 사용
업데이트에 작은 시간 간격을 강제로 사용하거나, 렌더링하는 각 프레임에 대해 여러 개의 작은 업데이트를 사용할 수 있습니다. 그러나 이 접근 방식은 큰 이점을 제공하지 않습니다. 현실적인 충돌을 시뮬레이션하는 데 필요한 종류의 스프링 강성은 지금까지 구축한 프레임워크에서는 불가능합니다.

### 2. 강성 스프링 가짜 구현
더 발전된 스프링 힘 생성기를 구현하여 강성 스프링을 작동시키는 "속임수"를 제공할 수 있습니다. 이 방법은 시간 간격에 따라 힘이 어떻게 변할지 예측하고, 그것을 사용하여 평균 힘을 생성합니다. 이를 "암시적 스프링(implicit spring)"이라고도 하며, 이런 방식으로 변화하는 힘을 처리할 수 있는 물리 엔진은 암시적(implicit) 또는 반암시적(semi-implicit)이라고 합니다.

#### 조화 운동(Harmonic Motion)
마찰이나 항력이 없는 스프링은 영원히 진동할 것입니다. 이러한 스프링을 특정 확장까지 늘린 다음 놓으면, 그 끝은 함께 가속됩니다. 자연 길이를 지나 압축되기 시작합니다. 끝이 처음에 확장된 정도와 정확히 같은 정도로 압축되면, 다시 벌어지기 시작합니다. 이것은 영원히 계속됩니다. 이런 종류의 운동은 물리학자들에게 잘 알려져 있으며, "단순 조화 운동(simple harmonic motion)"이라고 합니다.

스프링 한쪽 끝의 위치는 다음 방정식을 따릅니다:

<div style="font-size: 1.5em; text-align: center; margin: 20px 0;">
p¨ = -χ² · p
</div>

여기서 k는 스프링 상수, m은 물체의 질량, χ는 다음과 같이 정의됩니다:

<div style="font-size: 1.5em; text-align: center; margin: 20px 0;">
χ = √(k/m)
</div>

이 방정식은 "미분 방정식"이라고 불립니다. 이 방정식은 다음과 같이 해결됩니다:

<div style="font-size: 1.5em; text-align: center; margin: 20px 0;">
p<sub>t</sub> = p<sub>0</sub> · cos(χt) + (p˙<sub>0</sub>/χ) · sin(χt)
</div>

여기서 p₀는 예측 시작 시 자연 길이에 대한 스프링 끝의 위치이고, p˙₀는 같은 시간의 속도입니다.

현재 프레임의 지속 시간을 이 방정식에 대입하여 스프링이 자체적으로 움직일 경우 어디에 도달할지 계산할 수 있습니다. 그런 다음 프레임 지속 시간 동안 정확한 위치에 도달하기에 충분한 힘을 만들 수 있습니다.

#### 감쇠 조화 운동(Damped Harmonic Motion)
실제 스프링은 스프링 힘뿐만 아니라 항력도 경험합니다. 스프링은 계속해서 같은 지점까지 진동하지 않을 것입니다. 최대 확장은 매번 줄어들어 결국 휴지 길이에서 안정됩니다. 이 점진적인 감소는 스프링이 경험하는 항력에 의해 발생합니다.

감쇠를 포함한 미분 방정식은 다음과 같습니다:

<div style="font-size: 1.5em; text-align: center; margin: 20px 0;">
p¨ = -kp - dp˙
</div>

여기서 k는 스프링 상수이고 d는 항력 계수입니다.

이 방정식을 풀면 미래의 임의 시간에 대한 위치 표현식이 나옵니다:

<div style="font-size: 1.5em; text-align: center; margin: 20px 0;">
p<sub>t</sub> = [p<sub>0</sub> · cos(γt) + c · sin(γt)] · e<sup>-½dt</sup>
</div>

여기서 γ와 c는 다음과 같이 주어지는 상수입니다:

<div style="font-size: 1.5em; text-align: center; margin: 20px 0;">
γ = ½ · √(4k - d²)
</div>

<div style="font-size: 1.5em; text-align: center; margin: 20px 0;">
c = (d/2γ) · p<sub>0</sub> + (1/γ) · p˙<sub>0</sub>
</div>

### 가짜 암시적 스프링 구현

```cpp
class ParticleFakeSpring : public ParticleForceGenerator
{
    // 스프링의 고정된 끝 위치
    Vector3 *anchor;
    // 스프링 상수
    real springConstant;
    // 스프링 진동의 감쇠
    real damping;

public:
    // 주어진 매개변수로 새 스프링 생성
    ParticleFakeSpring(Vector3 *anchor, real springConstant, real damping);
    // 주어진 파티클에 스프링 힘 적용
    virtual void updateForce(Particle *particle, real duration);
};

void ParticleFakeSpring::updateForce(Particle* particle, real duration)
{
    // 무한 질량이 아닌지 확인
    if (!particle->hasFiniteMass()) return;
    
    // 앵커에 대한 파티클의 상대 위치 계산
    Vector3 position;
    particle->getPosition(&position);
    position -= *anchor;
    
    // 상수 계산 및 범위 내에 있는지 확인
    real gamma = 0.5f * real_sqrt(4 * springConstant - damping*damping);
    if (gamma == 0.0f) return;
    
    Vector3 c = position * (damping / (2.0f * gamma)) +
                particle->getVelocity() * (1.0f / gamma);
    
    // 목표 위치 계산
    Vector3 target = position * real_cos(gamma * duration) +
                    c * real_sin(gamma * duration);
    target *= real_exp(-0.5f * duration * damping);
    
    // 결과 가속도 및 힘 계산
    Vector3 accel = (target - position) * (1.0f / duration*duration) -
                    particle->getVelocity() * duration;
    particle->addForce(accel * particle->getMass());
}
```

이 힘 생성기는 이전에 만든 고정점 스프링 생성기와 비슷하지만, 중요한 차이점이 있습니다: 더 이상 자연 스프링 길이가 없습니다. 이는 여기서 사용된 수학의 결과입니다. 결과적으로 항상 휴지 길이가 0이어야 합니다.

## 가짜 암시적 스프링의 제한 사항

### 1. 0 휴지 길이 제한
스프링의 휴지 길이가 0이면 스프링의 한쪽 끝이 이동할 때마다 스프링이 확장됩니다. 스프링의 한쪽 끝을 고정하면 항상 고정된 끝 방향으로 힘이 작용합니다.

스프링의 양쪽 끝이 모두 움직일 수 있는 경우, 힘의 방향을 결정하는 것은 훨씬 더 어렵습니다. 이전 공식은 힘이 물체의 위치만으로 표현될 수 있다고 가정합니다. 스프링을 고정하지 않으면 방정식에 스프링의 다른 쪽 끝의 움직임을 포함해야 하며, 이는 방정식을 풀 수 없게 만듭니다.

### 2. 속도 불일치
지금까지 위치에 대해서만 이야기했습니다. 방정식은 물체를 예측된 위치로 이동시키는 데 필요한 힘을 계산합니다. 불행히도 정확한 속도로 도달하지는 않습니다(종종 가깝긴 하지만). 이 방정식이 매번 물체의 속도를 증가시켜 점점 더 빨라지고 무한대로 폭발할 수 있을까요?

감쇠 조화 운동의 경우, 앵커 포인트가 움직이지 않을 때, 이런 종류의 예측을 수행한 결과 속도는 절대 이런 상태에 도달하지 않을 것입니다.

속도 불일치는 스프링이 일관되지 않은 스프링 상수로 작동하게 합니다. 때로는 우리가 지정한 것보다 더 강성이 있고, 때로는 더 느슨합니다. 대부분의 경우 눈에 띄지 않지만, 이는 우리가 한 방식으로 힘을 속이는 불가피한 결과입니다.

### 3. 다른 힘과의 상호 작용
가짜 스프링 생성기의 또 다른 주요 제한 사항은 다른 힘과 상호 작용하는 방식입니다.

이전 방정식은 물체가 다른 힘의 영향을 받지 않고 자유롭게 움직인다고 가정합니다. 스프링 힘은 시간 간격 동안 감소할 것입니다. 스프링이 휴지 길이를 향해 움직이기 때문입니다. 스프링을 일정한 길이로 확장하거나 압축 상태로 유지하는 다른 힘이 있다면, 힘은 일정할 것이고, 원래 힘 생성기는 스프링 상수가 무엇이든 완벽한 결과를 제공할 것입니다.

이론적으로 다른 모든 힘을 스프링 생성기의 예측에 통합할 수 있으며, 그러면 정확한 힘을 반환할 것입니다. 불행히도, 힘을 올바르게 계산하려면 시뮬레이션되는 모든 물체의 동작을 알아야 합니다. 모든 물체의 동작을 시뮬레이션하는 것은 물리 엔진의 전체 목적입니다. 따라서 이것이 작동하도록 할 수 있는 유일한 방법은 힘 계산에 전체 물리 엔진을 넣는 것입니다. 이는 실용적이지 않습니다.

확장된 상태로 유지되도록 의도된 스프링(예: 이전 장에서 로프 다리를 지지하는 스프링)의 경우, 가짜 스프링 힘은 너무 작을 것입니다. 실제로는 원하는 효과를 얻기 위해 다양한 기법의 조합을 찾는 것이 가장 좋습니다.

## 결론

후크의 법칙을 사용하여 놀라운 수의 물리적 효과를 모델링할 수 있습니다. 부력과 같은 일부 효과는 스프링과 매우 유사한 특성을 가지고 있어 동일한 코드를 사용하여 가장 간단하게 지원됩니다.

그러나 높은 스프링 상수(즉, 빠르고 강한 반동을 가진)를 가진 스프링은 프레임별로 시뮬레이션하기 어렵다는 문제가 있습니다. 스프링의 작용이 시뮬레이션된 프레임 사이의 시간보다 빠를 때, 스프링은 통제를 벗어나 불안정해질 수 있습니다.

이 문제가 없다면 스프링과 유사한 힘을 사용하여 거의 모든 것을 시뮬레이션할 수 있습니다. 예를 들어, 모든 충돌을 쉽게 처리할 수 있습니다. 일부 경우에 강성 스프링을 속일 수 있었지만, 이 솔루션은 일반적인 경우에 강성 스프링을 처리할 만큼 견고하지 않습니다. 따라서 충돌의 매우 빠른 반동을 처리하기 위해 대체 접근 방식을 찾아야 합니다.

---

**참고 자료**: Game Physics Engine Development, Chapter 6: Springs and Springlike Things 